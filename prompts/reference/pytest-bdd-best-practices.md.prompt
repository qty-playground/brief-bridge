# Pytest-BDD Best Practices Reference

## Overview
This document provides pytest-bdd implementation patterns and best practices based on proven examples.

## Required Reading
**MUST read these files before proceeding:**

Use the Read tool to load:
1. `prompts/reference/python-coding-style.md.prompt` - For coding standards
2. `docs/clean-architecture-structure.md` - For architecture design
3. `docs/domain-model.md` - For business rules and entities

## Step Definition Syntax

### Basic Step Definitions

**Correct Pattern:**
```python
import pytest
from pytest_bdd import scenarios, given, when, then, parsers

# Load scenarios
scenarios('story.feature')

# Phase-aware test context fixture (provided by root conftest.py)
@pytest.fixture
def context() -> ScenarioContext:
    """
    BDD Test Context with phase-aware state management
    
    Enforces proper separation of concerns across Given-When-Then phases:
    - GIVEN: Can set input state and test data  
    - WHEN: Can collect execution results, cannot modify input state
    - THEN: Read-only access for assertions
    
    Example usage:
        def given_client_exists(context: ScenarioContext):
            context.set_phase(BDDPhase.GIVEN)
            context.client_id = "test-123"
            
        def when_query_status(context: ScenarioContext):
            context.set_phase(BDDPhase.WHEN)
            context.response = api.get_status(context.client_id)
            
        def then_status_is_online(context: ScenarioContext):
            context.set_phase(BDDPhase.THEN)
            assert context.response.status == "ONLINE"
    """
    return ScenarioContext()
```

## Phase-Aware ScenarioContext Usage

The ScenarioContext enforces proper BDD semantics by controlling state management across Given-When-Then phases.

### Phase Management

**Phase Transitions:**
```python
from conftest import ScenarioContext, BDDPhase

def test_example():
    ctx = ScenarioContext()
    
    # === GIVEN: Setup input state ===
    ctx.set_phase(BDDPhase.GIVEN)
    ctx.client_id = "test-123"
    ctx.api_endpoint = "/api/clients"
    ctx.request_data = {"name": "Test Client"}
    
    # === WHEN: Execute and collect results ===
    ctx.set_phase(BDDPhase.WHEN)
    # Can read input state
    endpoint = ctx.api_endpoint
    
    # Can collect results
    ctx.response = {"status": 201, "id": "generated-456"}
    ctx.execution_time = 0.234
    
    # ❌ Cannot modify input state
    # ctx.client_id = "new-id"  # Raises AttributeError
    
    # === THEN: Read-only assertions ===
    ctx.set_phase(BDDPhase.THEN)
    assert ctx.client_id == "test-123"  # Can read all state
    assert ctx.response["status"] == 201
    
    # ❌ Cannot modify any state
    # ctx.verification = True  # Raises AttributeError
```

### BDD Step Implementation with Phases

**GIVEN Steps - Input State Setup:**
```python
@given(parsers.parse('client "{client_id}" exists with status "{status}"'))
def given_client_exists_with_status(context: ScenarioContext, client_id: str, status: str):
    """Business rule: client.registration - setup test client"""
    context.set_phase(BDDPhase.GIVEN)
    context.client_id = client_id
    context.expected_status = status
    context.test_data = {"setup": "complete"}
```

**WHEN Steps - Execution and Result Collection:**
```python
@when('I query the client status')
def when_query_client_status(context: ScenarioContext):
    """Business rule: client.status_query - retrieve current status"""
    context.set_phase(BDDPhase.WHEN)
    
    # Use input state from GIVEN
    client_id = context.client_id
    
    # Execute production code
    result = production_service.get_client_status(client_id)
    
    # Collect results (allowed in WHEN)
    context.api_response = result
    context.actual_status = result.get("status")
    context.query_timestamp = result.get("timestamp")
    
    # ❌ This would raise error - cannot modify input state
    # context.client_id = "modified"  # AttributeError!
```

**THEN Steps - Read-only Verification:**
```python
@then('the status should match expected value')
def then_status_matches_expected(context: ScenarioContext):
    """Verify status query results match expectations"""
    context.set_phase(BDDPhase.THEN)
    
    # Read-only access to all state
    assert context.actual_status == context.expected_status
    assert context.api_response["client_id"] == context.client_id
    assert context.query_timestamp is not None
    
    # ❌ This would raise error - no state modification in THEN
    # context.verification_result = True  # AttributeError!
```

### State Introspection

**Debugging and Inspection:**
```python
# Get input state set during GIVEN phase
input_state = context.get_input_state()
print(input_state)  # {"client_id": "test-123", "expected_status": "ONLINE"}

# Get results collected during WHEN phase
results = context.get_results()  
print(results)  # {"api_response": {...}, "actual_status": "ONLINE"}

# Check current phase
current_phase = context.get_phase()
print(current_phase)  # BDDPhase.THEN
```

### Error Handling

**Phase Violation Examples:**
```python
# ❌ Wrong: Modifying input state in WHEN phase
context.set_phase(BDDPhase.WHEN)
context.new_input = "not allowed"  # OK - new result
context.client_id = "modified"     # AttributeError: Cannot modify input state

# ❌ Wrong: Any modification in THEN phase  
context.set_phase(BDDPhase.THEN)
context.verification = True        # AttributeError: THEN phase is read-only

# Error messages are descriptive:
# "Cannot modify input state 'client_id' in WHEN phase. Input state can only be set in GIVEN phase."
# "Cannot set attribute 'verification' in THEN phase. THEN phase is read-only for assertions."
```

### Step Definition Patterns

#### 1. Simple String Matching
```python
@given('client is online')
def given_client_is_online(context):
    context.client_status = 'ONLINE'
```

#### 2. Parameter Extraction
```python
@given(parsers.parse('client "{client_id}" is online'))
def given_client_is_online_in_system(context: dict, client_id: str) -> None:
    """Business rule: client.registration - set up online client for testing"""
    context['client_id'] = client_id
    context['client_status'] = 'ONLINE'
```

#### 3. Type Conversion
```python
@then(parsers.parse('response status code should be {status_code:d}'))
def then_status_code(context, status_code):
    assert context.response.status_code == status_code
```

#### 4. Docstring Handling (Multiline Strings)
```python
# Feature file:
# Given client exists with data:
#   """
#   {"client_id": "123", "status": "ONLINE"}
#   """

@given(parsers.parse('client exists with data:'))
def given_client_exists_with_data_in_system(context: dict, docstring: str) -> None:
    """Business rule: client.registration - create client from provided data
    
    IMPORTANT: 'docstring' is a FIXED parameter name - cannot be changed
    """
    import json
    from brief_bridge.domain.entities.client import Client
    from brief_bridge.domain.value_objects.client_id import ClientId
    from brief_bridge.domain.value_objects.client_info import ClientInfo
    
    client_data = json.loads(docstring)
    client = Client(
        ClientId(client_data['client_id']),
        ClientInfo.from_dict(client_data)
    )
    context['client_data'] = client_data
    context['client_entity'] = client
```

**CRITICAL: Docstring Parameter Name Rules**
- The parameter MUST be named `docstring` - this is pytest-bdd convention
- You CANNOT rename it to `json_data`, `content`, or any other name
- pytest-bdd automatically injects multiline strings into the `docstring` parameter

#### 5. Data Tables
```python
# Feature file:
# Given following clients exist:
#   | client_id | status  | type    |
#   | client-1  | ONLINE  | desktop |
#   | client-2  | OFFLINE | mobile  |

@given('following clients exist:')
def given_clients_exist(context, datatable):
    """datatable parameter automatically receives the data table"""
    # datatable is a list of lists: [['client_id', 'status', 'type'], ['client-1', 'ONLINE', 'desktop'], ...]
    headers = datatable[0]
    for row in datatable[1:]:
        client_dict = dict(zip(headers, row))
        context.test_objects.append(client_dict)
```

## HTTP API Testing Patterns

### FastAPI Test Client Integration
```python
import pytest
from fastapi.testclient import TestClient
from your_app.main import app

@pytest.fixture
def test_client():
    """FastAPI test client"""
    return TestClient(app)

@pytest.fixture 
def api_context(test_client):
    """API test context with HTTP client"""
    return type('ApiContext', (), {
        'client': test_client,
        'last_response': None,
        'test_data': {}
    })()

@when(parsers.parse('I POST to "{endpoint}" with:'))
def when_i_post_to_endpoint_with_payload(api_context: dict, endpoint: str, docstring: str) -> None:
    """Execute HTTP POST with JSON payload from docstring
    
    Business rule: api.interaction - trigger system action through HTTP interface
    IMPORTANT: 'docstring' parameter name is FIXED - cannot be renamed
    """
    import json
    from fastapi.testclient import TestClient
    
    payload = json.loads(docstring)
    test_client: TestClient = api_context['client']
    response = test_client.post(endpoint, json=payload)
    api_context['last_response'] = response

@then(parsers.parse('response status code should be {status_code:d}'))
def then_response_status_code_should_be(api_context: dict, status_code: int) -> None:
    """Verify HTTP response status code matches expectation
    
    Validates external system behavior through HTTP interface
    """
    from requests import Response
    
    response: Response = api_context['last_response']
    assert response.status_code == status_code, f"Expected status {status_code}, got {response.status_code}"

@then(parsers.parse('response body should contain:'))
def then_response_body_contains(api_context, docstring):
    """Verify response body contains expected JSON structure
    IMPORTANT: 'docstring' parameter name is FIXED - cannot be renamed"""
    import json
    expected = json.loads(docstring)
    actual = api_context.last_response.json()
    
    for key, expected_value in expected.items():
        assert key in actual, f"Missing key: {key}"
        
        # Handle placeholder values like <uuid>
        if isinstance(expected_value, str) and expected_value.startswith('<') and expected_value.endswith('>'):
            # For placeholders, just verify key exists and has value
            assert actual[key] is not None, f"Key {key} should have value"
        else:
            # For concrete values, check exact match
            assert actual[key] == expected_value, f"Expected {key}={expected_value}, got {actual[key]}"
```

## Common Patterns

### 1. Database Setup and Teardown
```python
@given(parsers.parse('database contains {table_name} data:'))
def given_database_data(db_session, table_name, datatable):
    """Set up database data from data table
    IMPORTANT: 'datatable' parameter name is FIXED - cannot be renamed"""
    headers = datatable[0]
    for row in datatable[1:]:
        record_dict = dict(zip(headers, row))
        # Create database record
        # db_session.add(YourModel(**record_dict))
    # db_session.commit()
```

### 2. Context Data Verification
```python
@then(parsers.parse('context should contain {key} with value "{expected_value}"'))
def then_context_contains(context, key, expected_value):
    """Verify test context contains expected data"""
    assert hasattr(context, key), f"Context missing key: {key}"
    actual_value = getattr(context, key)
    assert str(actual_value) == expected_value
```

### 3. Complex JSON Matching
```python
@then(parsers.parse('response should match schema:'))
def then_response_matches_schema(api_context, docstring):
    """Verify response matches JSON schema pattern
    IMPORTANT: 'docstring' parameter name is FIXED - cannot be renamed"""
    import json
    expected_schema = json.loads(docstring)
    actual_response = api_context.last_response.json()
    
    def matches_schema(actual, expected):
        if isinstance(expected, dict):
            for key, expected_value in expected.items():
                assert key in actual, f"Missing key: {key}"
                matches_schema(actual[key], expected_value)
        elif isinstance(expected, list):
            assert isinstance(actual, list), "Expected list"
            if expected:  # If expected list has items, validate structure
                for item in actual:
                    matches_schema(item, expected[0])
        elif isinstance(expected, str) and expected.startswith('<') and expected.endswith('>'):
            # Placeholder - just verify non-null
            assert actual is not None
        else:
            assert actual == expected
    
    matches_schema(actual_response, expected_schema)
```

## File Organization

### Recommended Structure
```
tests/
├── feature_name/
│   ├── __init__.py
│   ├── story.feature              # BDD scenarios
│   ├── test_feature_name.py       # Step definitions
│   ├── conftest.py               # Feature-specific fixtures
│   └── support/
│       ├── __init__.py
│       ├── context_helpers.py     # Context management utilities
│       └── data_builders.py       # Test data creation helpers
```

### Feature-Specific Fixtures
```python
# tests/feature_name/conftest.py
import pytest

@pytest.fixture
def feature_context():
    """Feature-specific test context"""
    return type('FeatureContext', (), {
        'entities': {},
        'responses': [],
        'test_state': {}
    })()

@pytest.fixture
def feature_dependencies():
    """Set up feature-specific dependencies"""
    # Set up repositories, services, etc.
    pass
```

## Best Practices

### DO ✅
- Use `parsers.parse()` for parameter extraction
- Use fixtures for test context instead of global variables
- Keep step definitions focused and single-purpose
- Use descriptive parameter names that match business language
- Handle docstrings and datatables explicitly as function parameters
- Use type hints in parsers (e.g., `{status_code:d}`)
- Structure test data using fixtures and builders
- **Set correct BDD phase at the beginning of each step implementation**
- **Use GIVEN for input state setup, WHEN for result collection, THEN for assertions**
- **Leverage state introspection methods for debugging (`get_input_state()`, `get_results()`)**

### DON'T ❌
- Use global variables for test state
- Mix business logic into step definitions
- Ignore type conversion for extracted parameters
- Use magic strings or hardcoded values
- Couple step definitions to specific test scenarios
- Put complex logic directly in step functions
- **Modify input state in WHEN or THEN phases**
- **Set any attributes in THEN phase (read-only)**
- **Skip phase transitions - always use `context.set_phase()`**

## Error Handling

### Common Issues and Solutions

#### 1. StepDefinitionNotFoundError
```python
# ❌ Wrong: Missing parsers.parse()
@given('client "{client_id}" exists')

# ✅ Correct: Use parsers.parse()
@given(parsers.parse('client "{client_id}" exists'))
```

#### 2. Fixture Not Found Error
```python
# ❌ Wrong: Expecting parameter that doesn't exist
@when('I perform action')
def step_perform_action(non_existent_param):
    pass

# ✅ Correct: Use proper fixtures
@when('I perform action')  
def step_perform_action(context):
    pass
```

#### 3. Docstring Parameter Mismatch
```python
# ❌ Wrong: Not expecting docstring parameter
@given('data exists:')
def step_data_exists(context):
    pass  # docstring will cause fixture error

# ❌ Wrong: Using wrong parameter name  
@given('data exists:')
def step_data_exists(context, json_data):  # WRONG - must be 'docstring'
    pass

# ✅ Correct: Accept docstring parameter with FIXED name
@given('data exists:')
def step_data_exists(context, docstring):  # MUST use 'docstring' name
    pass
```

**CRITICAL: Fixed Parameter Names**
- `docstring` - for multiline strings (""" ... """)
- `datatable` - for data tables (| ... |)
- These names are pytest-bdd conventions and CANNOT be changed

#### 4. Phase Management Violations
```python
# ❌ Wrong: Not setting phase in step
@given('client exists')
def given_client_exists(context):
    context.client_id = "test"  # May fail if not in GIVEN phase

# ✅ Correct: Always set phase first
@given('client exists')
def given_client_exists(context: ScenarioContext):
    context.set_phase(BDDPhase.GIVEN)
    context.client_id = "test"

# ❌ Wrong: Modifying input state in WHEN
@when('I execute action')
def when_execute_action(context: ScenarioContext):
    context.set_phase(BDDPhase.WHEN)
    context.client_id = "modified"  # AttributeError!

# ✅ Correct: Only collect results in WHEN
@when('I execute action')
def when_execute_action(context: ScenarioContext):
    context.set_phase(BDDPhase.WHEN)
    context.execution_result = execute_something(context.client_id)

# ❌ Wrong: Setting attributes in THEN
@then('result should be valid')  
def then_result_valid(context: ScenarioContext):
    context.set_phase(BDDPhase.THEN)
    context.validation_result = True  # AttributeError!

# ✅ Correct: Only read state in THEN
@then('result should be valid')
def then_result_valid(context: ScenarioContext):
    context.set_phase(BDDPhase.THEN)
    assert context.execution_result.is_valid()
```

**CRITICAL: Phase Management Rules**
- **GIVEN**: Can set input state and test data
- **WHEN**: Can collect results, cannot modify input state  
- **THEN**: Read-only access for assertions
- Always call `context.set_phase()` at the beginning of each step

## Performance Tips

1. **Use session-scoped fixtures** for expensive setup
2. **Lazy load test dependencies** in fixtures
3. **Clean up test data** in fixture teardown
4. **Use database transactions** for test isolation
5. **Mock external services** to avoid network calls

This reference provides the foundation for reliable pytest-bdd implementations that follow established patterns and avoid common pitfalls.