# Brief Bridge BDD Implementation - Overview

## Mission
Implement Brief Bridge system using systematic BDD (Behavior-Driven Development) approach with pytest-bdd, following simplified architecture principles focused on testability and maintainability.

## Implementation Methodology

This systematic 4-phase approach ensures proper test-driven development:

**Phase 1: Synchronize User Stories to Feature Files** (`01-user-stories-to-features.md.prompt`)
- Convert user stories to Gherkin feature files
- Establish consistent naming and structure
- Mark all scenarios with @skip initially

**Phase 2: Create Testing Walking Skeleton** (`02-walking-skeleton.md.prompt`)  
- Build pytest-bdd infrastructure shell
- Create step definition skeletons
- Establish test discovery structure

**Phase 3: TDD RED-GREEN-REFACTOR Cycle** (`03-tdd-red-green-refactor.md.prompt`)
- Implement one scenario at a time using TDD
- Two-stage GREEN: Infrastructure Shell → Business Rules
- Focus REFACTOR on code quality only

**Phase 4: Next Iteration Cycle** (`04-iteration-cycle.md.prompt`)
- Move to next scenario within feature
- Repeat TDD cycle until feature complete
- Move to next feature file

## Validation Tools

Always use these validation prompts after completing scenarios:
- `validation/domain-model-check.md.prompt`: Ensure alignment with domain design
- `validation/clean-architecture-check.md.prompt`: Verify dependency directions
- `validation/test-responsibility-check.md.prompt`: Check test/production boundaries

## Reference Materials

- `reference/pytest-commands.md.prompt`: Pytest execution commands
- `reference/do-dont-rules.md.prompt`: Implementation rules and guidelines

## Key Project Documents

These documents contain the design specifications:
- `docs/domain-model.md`: Business entities, rules, and relationships
- `docs/clean-architecture-structure.md`: Code organization and dependencies  
- `docs/user-stories/`: Detailed technical specifications per feature
- `docs/prd.md`: Business requirements and context
- `prompts/reference/python-coding-style.md.prompt`: Python coding standards for simplified architecture

## Usage Instructions

1. **Choose your starting point**:
   - New project: Start with `01-user-stories-to-features.md.prompt`
   - Existing features: Jump to appropriate phase prompt
   - Problem diagnosis: Use validation prompts

2. **Follow phase sequence**: Each prompt guides to the next logical step

3. **Validate frequently**: Use validation prompts after each completed scenario

4. **Reference documents**: Each prompt specifies which project documents to read

## Success Criteria

- All user story scenarios implemented as passing BDD tests
- Clean Architecture principles maintained throughout  
- All business rules properly enforced in domain layer
- Test responsibilities clearly separated from production code
- **Architecture stays simple** - avoid over-engineering, start minimal

## Simplified Architecture Philosophy

**CRITICAL: Framework ↔ UseCase ↔ Entity/Repository with Dependency Injection**

This development process emphasizes **practical simplicity** over architectural purity:

### Core Architecture
1. **Framework/Controller**: Handles HTTP requests, converts to simple data structures
2. **UseCase**: Business logic orchestration with injected dependencies
3. **Entity/Repository**: Business entities and data persistence
4. **One Data Conversion**: Framework DTO → UseCase input/output only

### Testing Strategy: Two Levels Only
1. **E2E Tests**: Through web framework (full integration)
2. **UseCase Tests**: Direct UseCase testing with mocked dependencies

### What We Build vs What We Avoid

**✅ We Build (Simple & Testable):**
- UseCases with dependency injection for external dependencies
- Simple entities with clear business methods
- Concrete repository implementations 
- Dict/simple classes for data inside UseCases
- Self-documenting method names

**❌ We Avoid (Over-Engineering):**
- Multiple abstraction layers
- Complex value object hierarchies
- Strict layered dependency enforcement
- Excessive interfaces before needed
- Complex domain events for simple state changes

### Development Philosophy
- **Testability over purity**: Easy to test is more important than perfect architecture
- **Dependency injection for external dependencies**: Repositories, services, APIs
- **Simple data structures internally**: Use what works, don't over-model
- **Business logic in entities**: Keep domain rules in entity classes
- **Practical over theoretical**: If it's hard to understand or test, simplify it

---

**Remember**: Build incrementally, validate continuously, refactor fearlessly.