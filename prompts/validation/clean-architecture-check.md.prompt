# Simplified Architecture Conformance Validation

## Objective
Validate that the implementation follows our simplified architecture (Framework â†” UseCase â†” Entity/Repository) with proper dependency injection and testability.

## When to Use
- After completing each scenario
- When suspecting architecture violations
- Before merging or releasing code
- When debugging dependency issues

## Required Reading
**MUST read these files before validation:**

Use the Read tool to load:
1. `docs/clean-architecture-structure.md` - Architecture design reference (adapted for simplified approach)
2. Current implementation in `brief_bridge/` directory
3. Test implementations in `tests/` directory
4. `prompts/reference/python-coding-style.md.prompt` - Simplified architecture coding standards

## Validation Process

### Step 1: Simplified Structure Verification

**Check directory structure matches simplified design:**
```
brief_bridge/
â”œâ”€â”€ entities/                  # Business entities with domain logic
â”œâ”€â”€ use_cases/                # Business use cases with dependency injection
â”œâ”€â”€ repositories/             # Data persistence (concrete implementations)
â””â”€â”€ web/                      # Framework layer (FastAPI controllers)
```

**Validation Checklist:**
- [ ] Core directories exist: entities/, use_cases/, repositories/, web/
- [ ] No over-engineered subdirectories (avoid domain/application/infrastructure split)
- [ ] Files placed appropriately for simplified architecture

### Step 2: Dependency Injection Analysis

**Core Rule: UseCases receive external dependencies via constructor injection**

**Check dependency injection patterns:**

**UseCases (brief_bridge/use_cases/) - DEPENDENCY INJECTION:**
```bash
# Check UseCases have injected dependencies
grep -r "def __init__" brief_bridge/use_cases/ | grep -v "self):"
```
- [ ] UseCases receive repositories/services in `__init__`
- [ ] UseCases don't directly instantiate external dependencies
- [ ] UseCases work with simple data structures (dict, simple classes)

**Entities (brief_bridge/entities/) - MINIMAL DEPENDENCIES:**
```bash
# Should find minimal external imports
grep -r "from brief_bridge" brief_bridge/entities/
```
- [ ] Entities contain business logic methods
- [ ] Entities avoid importing repositories or UseCases
- [ ] Entities use simple data types for attributes

**Repositories (brief_bridge/repositories/) - CONCRETE IMPLEMENTATIONS:**
- [ ] Repositories are concrete classes (not necessarily abstracted)
- [ ] Repository methods have clear business meaning
- [ ] Repositories can be easily mocked for testing

### Step 3: Testability Validation

**Testing Pattern Check:**

**UseCases should be easily testable:**
```python
# brief_bridge/use_cases/submit_command_use_case.py
class SubmitCommandUseCase:
    def __init__(self, client_repo: ClientRepository, command_repo: CommandRepository):
        self._client_repo = client_repo  # Injected for testability
        self._command_repo = command_repo  # Injected for testability
        
    async def execute(self, request: dict) -> dict:
        client = await self._client_repo.find(request["client_id"])
        if not client.can_accept_new_command():  # Business logic in entity
            raise ClientNotAvailableError()
        # ... rest of logic
```

**Simple concrete repositories:**
```python
# brief_bridge/repositories/client_repository.py
class ClientRepository:
    def __init__(self):
        self._clients = {}  # Simple storage
        
    async def save(self, client: Client) -> None:
        self._clients[client.client_id] = client
        
    async def find(self, client_id: str) -> Client:
        return self._clients.get(client_id)
```

**Framework layer converts data:**
```python
# brief_bridge/web/routers/commands.py  
@router.post("/commands")
async def submit_command(request: CommandRequest, use_case: SubmitCommandUseCase = Depends()):
    # Convert framework DTO to simple dict
    result = await use_case.execute({
        "client_id": request.client_id,
        "content": request.content
    })
    return result  # UseCase returns simple dict
```

## Core Simplified Architecture Rules

### Rule 1: Framework â†” UseCase â†” Entity/Repository Flow

**Check the data flow:**
- [ ] **Framework/Controllers** convert HTTP requests to simple data structures
- [ ] **UseCases** receive simple data (dict/simple classes) and return simple data
- [ ] **Entities** contain business logic and rules
- [ ] **Repositories** handle data persistence with clear methods

### Rule 2: Dependency Injection for Testability

**Check testability patterns:**
- [ ] **UseCases** receive all external dependencies via constructor
- [ ] **No direct instantiation** of repositories/services inside UseCases
- [ ] **Tests can easily mock** injected dependencies
- [ ] **Two testing levels**: E2E (via framework) and Unit (via UseCase)

**Example Test Validation:**
```python
# âœ… Good: UseCase is easily testable
def test_submit_command_use_case():
    # Mock injected dependencies
    client_repo = Mock()
    command_repo = Mock()
    use_case = SubmitCommandUseCase(client_repo, command_repo)
    
    # Simple data structures
    result = await use_case.execute({"client_id": "test", "content": "ls"})
    assert result["status"] == "success"

# âŒ Bad: Hard to test due to internal dependencies
class HardToTestUseCase:
    def execute(self, request):
        repo = ClientRepository()  # Hard to mock!
        client = repo.find(request["client_id"])
```

### Rule 3: Business Logic Location

**Check business rule placement:**
- [ ] **Business rules** implemented in Entity methods
- [ ] **UseCases** orchestrate but don't contain business logic
- [ ] **Controllers** only handle data conversion
- [ ] **Repositories** only handle data persistence

**Example Validation:**
```python
# âœ… Good: Business logic in entity
class Client:
    def can_accept_new_command(self) -> bool:
        """Business rule: client availability check"""
        return self.status == "ONLINE" and self.availability == "IDLE"

# âœ… Good: UseCase orchestrates
class SubmitCommandUseCase:
    async def execute(self, request: dict) -> dict:
        client = await self._client_repo.find(request["client_id"])
        if not client.can_accept_new_command():  # Uses entity business logic
            raise ClientNotAvailableError()

# âŒ Bad: Business logic in UseCase
class BadUseCase:
    async def execute(self, request: dict) -> dict:
        client = await self._client_repo.find(request["client_id"])
        # Business logic in wrong place!
        if client.status != "ONLINE" or client.availability != "IDLE":
            raise ClientNotAvailableError()
```

## Validation Commands

### Check Architecture Simplicity
```bash
# Look for over-engineering signs
find brief_bridge -name "*Interface.py" -o -name "*Factory.py" -o -name "*Abstract*.py"

# Should be minimal - only create abstractions when you have multiple implementations
```

### Check Dependency Injection
```bash
# UseCases should have dependencies in constructor
grep -r "def __init__" brief_bridge/use_cases/ | grep -v "self):"

# UseCases should not instantiate repositories directly
grep -r "Repository()" brief_bridge/use_cases/
```

### Check Business Logic Location
```bash
# Entities should have business methods
grep -r "def " brief_bridge/entities/ | grep -v "__init__"

# UseCases should delegate to entities for business logic
grep -r "if.*status\|if.*availability" brief_bridge/use_cases/
```

## Anti-Patterns to Avoid

### âŒ Over-Engineering
```python
# Don't create unnecessary abstractions
class AbstractRepositoryFactory(ABC): pass
class ClientRepositoryInterface(ABC): pass  # Unless you have multiple implementations

# Don't over-granularize value objects
@dataclass class ClientId: pass  # Just use string
@dataclass class CommandContent: pass  # Just use string
```

### âŒ Complex Data Structures
```python
# Don't over-complicate data inside UseCases
class ComplexRequest:
    def __init__(self):
        self.metadata = RequestMetadata()  # Too complex
        self.validation_rules = ValidationRules()  # Too complex

# Use simple structures instead
request = {"client_id": "123", "content": "ls -la"}  # Simple and clear
```

### âŒ Business Logic in Wrong Places
```python
# Don't put business logic in UseCases
class BadUseCase:
    def execute(self, request):
        # Business rule implemented here (wrong!)
        if client.status != "ONLINE" or client.availability != "IDLE":
            raise Error()

# Put business logic in entities
class Client:
    def can_accept_command(self) -> bool:
        # Business rule implemented here (correct!)
        return self.status == "ONLINE" and self.availability == "IDLE"
```

## Validation Completion Checklist

### Architecture Structure
- [ ] Simple directory structure without over-engineering
- [ ] UseCases use dependency injection
- [ ] Entities contain business logic
- [ ] Repositories are concrete and testable

### Testability
- [ ] UseCases can be easily unit tested
- [ ] Dependencies can be mocked
- [ ] Two-level testing strategy implemented
- [ ] No hard-coded dependencies

### Business Logic
- [ ] Business rules in entities, not UseCases
- [ ] UseCases orchestrate, don't implement business logic
- [ ] Simple data structures used throughout
- [ ] Framework only handles data conversion

### Practical Simplicity
- [ ] No unnecessary abstractions
- [ ] Code is easy to understand and maintain
- [ ] Testing is straightforward
- [ ] Architecture serves the business, not the other way around

## Action Items

**If validation passes:**
âœ… Architecture follows simplified principles - continue development

**If validation fails:**
ðŸ”§ Identify specific violations:
1. Move business logic from UseCases to entities
2. Implement dependency injection in UseCases
3. Simplify over-engineered abstractions
4. Ensure testability at two levels

**For ongoing quality:**
ðŸ“‹ Apply these validation criteria to all new code and refactoring