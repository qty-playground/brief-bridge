# Test Responsibility Boundary Validation

## Objective
Ensure BDD tests maintain proper boundaries between behavior specification and implementation details, with clear responsibility separation.

## When to Use
- After implementing each scenario
- When tests become complex or hard to maintain
- Before scenario completion to ensure test quality
- When debugging test failures or flakiness

## Required Reading
**MUST read these files before validation:**

Use the Read tool to load:
1. Current feature file: `tests/{feature}/story.feature`
2. Step implementations: `tests/{feature}/{given,when,then}_steps.py`
3. Domain model: `docs/domain-model.md` - For business rule reference
4. User story: `docs/user-stories/{feature}.md` - For expected behavior

## Test Responsibility Framework

### Level 1: Feature File (Behavior Specification)
**ONLY specifies WHAT the system should do**

**Correct Feature Content:**
```gherkin
Feature: Submit Command
  
  Scenario: Submit command to online idle client
    Given client "client-001" exists with status "ONLINE" and availability "IDLE"
    When I POST to "/commands" with:
      """
      {
        "client_id": "client-001", 
        "content": "ls -la"
      }
      """
    Then response status code should be 200
    And response body should match:
      """
      {
        "command_id": "{uuid}",
        "status": "PENDING"
      }
      """
```

**Feature File Validation Checklist:**
- [ ] **Business language**: Uses domain terminology, not implementation details
- [ ] **External perspective**: Describes system behavior from user viewpoint  
- [ ] **Observable outcomes**: All Then steps verify observable system responses
- [ ] **No implementation details**: No references to classes, methods, or internal structure
- [ ] **Domain-focused**: Steps relate to business concepts (Client, Command, etc.)

### Level 2: Step Definitions (Behavior Implementation)
**Translates business language to system actions**

**Step Responsibility Boundaries:**

**Given Steps - Test Data Setup:**
```python
@given('client "{client_id}" exists with status "{status}" and availability "{availability}"')
def given_client_exists_with_status_and_availability(client_id, status, availability):
    """
    ✅ RESPONSIBLE FOR: Setting up test preconditions
    ❌ NOT RESPONSIBLE FOR: Business logic implementation
    """
    # ✅ Correct: Delegates to domain layer
    client_info = ClientInfo.create_default_linux()
    client = Client(ClientId(client_id), client_info)
    client.set_status(ClientStatus(status))
    
    # Uses repository interface (not implementation details)
    asyncio.run(client_repository.save(client))
```

**When Steps - Action Execution:**
```python
@when('I POST to "{endpoint}" with: {json_payload}')
def when_i_post_to_endpoint_with_payload(endpoint, json_payload):
    """
    ✅ RESPONSIBLE FOR: Triggering system actions
    ❌ NOT RESPONSIBLE FOR: Validating business rules
    """
    # ✅ Correct: Captures response for Then steps to verify
    global test_context
    response = test_client.post(endpoint, json=json.loads(json_payload))
    test_context.last_response = response
```

**Then Steps - Outcome Verification:**
```python
@then('response status code should be {status_code:d}')
def then_response_status_code_should_be(status_code):
    """
    ✅ RESPONSIBLE FOR: Verifying observable outcomes
    ❌ NOT RESPONSIBLE FOR: Internal system state verification
    """
    # ✅ Correct: Verifies external system response
    assert test_context.last_response.status_code == status_code
```

**Step Implementation Validation Checklist:**
- [ ] **Given steps**: Only set up test preconditions using domain entities
- [ ] **When steps**: Only trigger system actions, capture responses
- [ ] **Then steps**: Only verify observable system outputs
- [ ] **No business logic**: Steps delegate to domain layer, don't implement rules
- [ ] **Interface usage**: Use domain interfaces, not concrete implementations

### Level 3: Domain Layer (Business Logic Implementation)
**WHERE business rules are actually implemented and tested**

**Business logic belongs here:**
```python
# brief_bridge/domain/entities/client.py
class Client:
    def assign_command(self, command: Command):
        """Business rule: client.concurrency - one command per client"""
        if self.has_active_command():
            raise ClientBusyError("Client already executing command")
        self._current_command = command
        self._availability = ClientAvailability.BUSY
        
    def is_available_for_command(self) -> bool:
        """Business rule: command.target_validation"""
        return (self._status == ClientStatus.ONLINE and 
                self._availability == ClientAvailability.IDLE)
```

## Common Test Responsibility Violations

### Violation 1: Business Logic in Steps

**❌ Wrong: Business rule implemented in step**
```python
@given('client "{client_id}" exists with status "{status}"')
def given_client_exists(client_id, status):
    client = Client(ClientId(client_id))
    # ❌ Business logic in test step
    if status == "OFFLINE":
        client._status = ClientStatus.OFFLINE
        client._last_heartbeat = datetime.now() - timedelta(minutes=10)
    else:
        client._status = ClientStatus.ONLINE
        client._last_heartbeat = datetime.now()
```

**✅ Correct: Delegate to domain entity**
```python
@given('client "{client_id}" exists with status "{status}"')
def given_client_exists(client_id, status):
    client = Client(ClientId(client_id))
    # ✅ Domain entity handles business logic
    if status == "OFFLINE":
        client.mark_offline()
    else:
        client.mark_online()
```

### Violation 2: Implementation Details in Feature File

**❌ Wrong: Technical implementation in Gherkin**
```gherkin
Scenario: Database constraint validation
  Given a Client entity exists in postgres table "clients"
  When I call ClientRepository.save() method
  Then a DatabaseConstraintError should be raised
```

**✅ Correct: Business behavior focus**
```gherkin  
Scenario: Reject duplicate client registration
  Given client "client-001" is already registered
  When I register client "client-001" again
  Then registration should be rejected with "Client already exists" error
```

### Violation 3: Internal State Verification in Then Steps

**❌ Wrong: Verifying internal object state**
```python
@then('client availability should be updated to "{availability}"')
def then_client_availability_updated(availability):
    # ❌ Accessing internal state
    client = test_context.created_client
    assert client._availability == ClientAvailability(availability)
```

**✅ Correct: Verifying observable system response**
```python
@then('client status endpoint should return availability "{availability}"')
def then_client_status_shows_availability(availability):
    # ✅ Verifying external system response
    response = test_client.get(f"/clients/{test_context.client_id}/status")
    assert response.json()["availability"] == availability
```

## Test Boundary Validation Process

### Step 1: Feature File Analysis

**Check each scenario for:**
- [ ] **User perspective**: Scenario reads like user requirement
- [ ] **Business language**: Uses domain terms, not technical jargon
- [ ] **Black box**: No internal implementation references
- [ ] **Observable**: All outcomes are externally verifiable

### Step 2: Given Steps Analysis  

**For each Given step:**
- [ ] **Precondition only**: Sets up required system state
- [ ] **Domain entities**: Uses proper domain entities and value objects
- [ ] **No business logic**: Delegates logic to domain layer
- [ ] **Repository interface**: Uses domain repository interfaces

### Step 3: When Steps Analysis

**For each When step:**
- [ ] **Action trigger**: Only triggers system actions
- [ ] **Response capture**: Captures responses for verification
- [ ] **No validation**: Doesn't validate outcomes (That's Then's job)
- [ ] **External interface**: Interacts through external system interface (HTTP, etc.)

### Step 4: Then Steps Analysis

**For each Then step:**
- [ ] **Observable verification**: Only checks external system responses
- [ ] **No internal access**: Doesn't access internal object state
- [ ] **Domain agnostic**: Doesn't know about internal domain implementation
- [ ] **User perspective**: Verifies what user would observe

### Step 5: Business Logic Location Check

**Verify business rules are in domain layer:**
- [ ] **Client management**: Rules in Client entity
- [ ] **Command processing**: Rules in Command entity  
- [ ] **Distribution logic**: Rules in domain services
- [ ] **Validation rules**: Rules in value objects

## Responsibility Matrix

| Component | Feature File | Given Steps | When Steps | Then Steps | Domain Layer |
|-----------|-------------|-------------|------------|-------------|-------------|
| **Business Requirements** | ✅ Specify | ❌ No | ❌ No | ❌ No | ✅ Implement |
| **Test Data Setup** | ❌ No | ✅ Coordinate | ❌ No | ❌ No | ❌ No |
| **System Actions** | ✅ Specify | ❌ No | ✅ Trigger | ❌ No | ❌ No |
| **Outcome Verification** | ✅ Specify | ❌ No | ❌ No | ✅ Verify | ❌ No |
| **Business Logic** | ❌ No | ❌ No | ❌ No | ❌ No | ✅ Implement |

## Validation Commands

**Check for business logic in steps:**
```bash
# Look for business rule implementation in test steps
grep -r "if.*status\|if.*availability\|BusinessRule" tests/*/given_steps.py tests/*/when_steps.py tests/*/then_steps.py
```

**Check for internal state access:**
```bash
# Look for internal attribute access
grep -r "\._[a-zA-Z]" tests/*/then_steps.py
```

**Check feature file language:**
```bash
# Look for technical implementation details
grep -r "Repository\|Entity\|Service\|Database" tests/*/story.feature
```

## Remediation Guidelines

### Fix Business Logic in Steps
1. **Move logic to domain entities/services**
2. **Update steps to use domain methods**
3. **Ensure proper separation of concerns**

### Fix Implementation Details in Features
1. **Rewrite scenarios from user perspective**
2. **Use business language instead of technical terms**
3. **Focus on observable system behavior**

### Fix Internal State Verification
1. **Replace with external system verification**
2. **Use HTTP endpoints or observable interfaces**
3. **Test behavior, not implementation**

## Completion Checklist

### Feature Files
- [ ] All scenarios use business language
- [ ] No implementation details referenced
- [ ] All outcomes are observable externally
- [ ] Scenarios read like user requirements

### Step Implementations
- [ ] Given steps only set up preconditions
- [ ] When steps only trigger actions
- [ ] Then steps only verify observable outcomes
- [ ] No business logic implemented in any steps

### Domain Integration
- [ ] All business rules implemented in domain layer
- [ ] Steps delegate to domain entities/services
- [ ] Repository interfaces used correctly
- [ ] Clean separation between test and business logic

### Test Quality
- [ ] Tests are maintainable and readable
- [ ] No duplication of business logic
- [ ] Tests focus on behavior, not implementation
- [ ] Clear responsibility boundaries maintained

## Next Steps

**If validation passes:**
✅ Test boundaries are correct - scenario ready for completion

**If violations found:**
🔧 Fix responsibility violations before proceeding

**For ongoing quality:**
📋 Apply these validation criteria to all future scenarios